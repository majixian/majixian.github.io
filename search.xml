<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Supervisor 进程管理]]></title>
    <url>%2F2017%2F12%2F17%2FSupversior%2F</url>
    <content type="text"><![CDATA[系统运行过程中难免会有一些常驻进程帮助我们处理一些业务逻辑，类似消费者进程或者服务程序。我们通常通过nohup 的方式来启动并在后台运行这个进程，如需更好的管理和监测这类进程，需要用到Supervisor 来对这种常驻进程进行监测管理。 简介supervisor 是用Python开发的一套通用的进程管理程序，可以将一个进程变为后台daemon，并监控进程状态，如果进程出现异常，可自动重启。 安装1yum -y install supervisor 注：Centos下安装 配置配置全局信息安装完成后，可在 /etc 下看到 supervisor.conf 这个文件，如下是该文件部分内容（需要简单配置的） 123456789101112131415161718192021222324252627282930313233[unix_http_server]file=/tmp/supervisor.sock ; UNIX socket 文件，supervisorctl 会使用;chmod=0700 ; socket 文件的 mode，默认是 0700;chown=nobody:nogroup ; socket 文件的 owner，格式： uid:gid ;[inet_http_server] ; HTTP 服务器，提供 web 管理界面;port=127.0.0.1:9001 ; Web 管理后台运行的 IP 和端口，如果开放到公网，需要注意安全性;username=user ; 登录管理后台的用户名;password=123 ; 登录管理后台的密码 [supervisord]logfile=/tmp/supervisord.log ; 日志文件，默认是 $CWD/supervisord.loglogfile_maxbytes=50MB ; 日志文件大小，超出会 rotate，默认 50MBlogfile_backups=10 ; 日志文件保留备份数量默认 10loglevel=info ; 日志级别，默认 info，其它: debug,warn,tracepidfile=/tmp/supervisord.pid ; pid 文件nodaemon=false ; 是否在前台启动，默认是 false，即以 daemon 的方式启动minfds=1024 ; 可以打开的文件描述符的最小值，默认 1024minprocs=200 ; 可以打开的进程数的最小值，默认 200 ; the below section must remain in the config file for RPC; (supervisorctl/web interface) to work, additional interfaces may be; added by defining them in separate rpcinterface: sections[rpcinterface:supervisor]supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface [supervisorctl]serverurl=unix:///tmp/supervisor.sock ; 通过 UNIX socket 连接 supervisord，路径与 unix_http_server 部分的 file 一致;serverurl=http://127.0.0.1:9001 ; 通过 HTTP 的方式连接 supervisord ; 包含其他的配置文件[include]files = relative/directory/*.ini ; 可以是 *.conf 或 *.ini 配置不同的进程管理从上面的配置文件中我们看到有 12[include]files = relative/directory/*.ini ; 可以是 *.conf 或 *.ini 我们可以新建 /etc/supervisor.d 文件夹，将不同的项目启动配置放在里面。 新建a.conf，内容如下： 12345678910[program:monitor_cron_master]command=sh /xxx/xxx/xxx/xxx/supervisor_monitor.shautostart = true ; 在 supervisord 启动的时候也自动启动startsecs = 5 ; 启动 5 秒后没有异常退出，就当作已经正常启动了autorestart = true ; 程序异常退出后自动重启startretries = 3 ; 启动失败自动重试次数，默认是 3user = root ; 用哪个用户启动redirect_stderr = true ; 把 stderr 重定向到 stdout，默认 falsestdout_logfile = /xxx/xxx/xxx/monitor_cron_master.log 注意：我们可能在代码编写过程中没有注意到程序运行中的一些相对路径的依赖，这样command 配置有可能变成 1cd /xxx/xxx/xxx &amp;&amp; sh a.sh command 是不支持这种配置方式的，在这种情况下我们可把这个命令放到一个shell 文件中，用shell 来启动管理程序。 启动监控启动服务1service supervisord start 注：修改 /etc/supervisord.conf 之后需要重启服务才可生效 查看123supervisorctl statusmonitor_cron_master RUNNING pid 6766, uptime 5 days, 15:39:11 可以看到进程的状态时间等信息 重启暂停12supervisorctl restart monitor_cron_mastersupervisorctl stop monitor_cron_master 添加进程管理 在 /etc/supervisor.d 下配置文件之后 1supervisorctl reread 这个命令只影响新增的配置，不会影响之前运行中的状态，执行下面的操作即可查看 1supervisorctl update]]></content>
  </entry>
  <entry>
    <title><![CDATA[LT1求数组下标]]></title>
    <url>%2F2017%2F12%2F15%2FLeetcode_twoSum%2F</url>
    <content type="text"><![CDATA[我们开始练习第一道算法题。 题目Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 解法法一我们可以简单的用两层嵌套循环的方法找出来，当然这样是最差的一种解法，时间复杂度 O(n²)，如下 123456789101112131415func twoSum(nums []int, target int) []int &#123; k1 := 0 k2 := 0 for i := 0; i &lt; len(nums); i++ &#123; for j := i + 1; j &lt; len(nums); j++ &#123; if nums[i]+nums[j] == target &#123; k1 = i k2 = j break &#125; &#125; &#125; return []int&#123;k1, k2&#125;&#125; 法二我们可以借助简单的数据结构来实现更高效的解法。用Map，Map中查找一个数的时间复杂度为 O(1)，如下的解法时间复杂度可为 O(n) 12345678910111213141516171819202122func twoSum1(nums []int, target int) []int &#123; arr := make(map[int]int) var t, k1, k2 int for i := 0; i &lt; len(nums); i++ &#123; arr[nums[i]] = i &#125; for i := 0; i &lt; len(nums); i++ &#123; t = target - nums[i] v, ok := arr[t] if ok &amp;&amp; v != i &#123; k1 = i k2 = v break &#125; &#125; return []int&#123;k1, k2&#125;&#125;]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM 配置PHP错误检查]]></title>
    <url>%2F2017%2F12%2F13%2Fvimchecker_php%2F</url>
    <content type="text"><![CDATA[VIM，素有编辑器之神的美名，缘于其强大的功能和众多高效的插件。今天我们来看看如何进行简单的配置来提高PHP开发及调试的效率。 使用场景笔者在开发和测试过程当中，自己或者QA同学都会遇到因为遗漏某个括号，或者分号这种小的语法错误导致工作效率降低，特别是在测试或者是预上线环境，所以本文提供了一个在编辑退出时自动检查语法错误的工具，提高开发测试效率。 配置插件将下面这段代码添加至yourname.vim 文件中，并将该文件移至 ~/.vim/plugin 文件下即可 123456789101112autocmd BufWritePost *.php call PHPSyntaxCheck()if !exists('g:PHP_SYNTAX_CHECK_BIN') let g:PHP_SYNTAX_CHECK_BIN = 'php'endiffunction! PHPSyntaxCheck() let result = system(g:PHP_SYNTAX_CHECK_BIN.' -l -n '.expand('%')) if (stridx(result, 'No syntax errors detected') == -1) echohl WarningMsg | echo result | echohl None endifendfunction]]></content>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang 基础知识]]></title>
    <url>%2F2017%2F12%2F10%2FGolang_first%2F</url>
    <content type="text"><![CDATA[Go 是一种新的语言，一种并发的、带垃圾回收的、快速编译的语言。 安装yum 安装1yum -y install goalng 源码安装移步Golang 官网 下载相应的源码包 1tar -xzf xxx.tar.gz -C /usr/local 环境配置查看当前环境12345678910111213141516 ~ go env GOARCH="amd64"GOBIN=""GOEXE=""GOHOSTARCH="amd64"GOHOSTOS="linux"GOOS="linux"GOPATH=""GORACE=""GOROOT="/usr/lib/golang"GOTOOLDIR="/usr/lib/golang/pkg/tool/linux_amd64"CC="gcc"GOGCCFLAGS="-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build643187888=/tmp/go-build"CXX="g++"CGO_ENABLED="1" 新建环境目录1234567vim .bash_profile//添加export GOPATH=/data0/www/htdocs/goexport PATH=$PATH:$GOPATH/bin//生效source .bash_profile 创建工作目录1234567mkdir /data0/www/htdocs/go//可执行文件mkdir /data0/www/htdocs/go/bin//源代码mkdir /data0/www/htdocs/go/src//依赖包mkdir /data0/www/htdocs/pkg 测试在 /data0/www/htdocs/go/src 下新建 main.go，添加如下代码 12345678910package mainimport ( "fmt")func main() &#123; fmt.Println("Welcome to Golang!")&#125; 运行 12[root@10 src]# go run main.goWelcome to Golang! 其他命令12345678910111213141516171819202122232425~ goGo is a tool for managing Go source code.Usage: go command [arguments]The commands are: build compile packages and dependencies clean remove object files doc show documentation for package or symbol env print Go environment information fix run go tool fix on packages fmt run gofmt on package sources generate generate Go files by processing source get download and install packages and dependencies install compile and install packages and dependencies list list packages run compile and run Go program test test packages tool run specified go tool version print Go version vet run go tool vet on packages 基础知识梳理Exercise at https://tour.golang.org/welcome/1 通过上述简单的测试程序，我们简单做一个阐述： Golang是通过包（package）来组织代码 每一个可独立运行的程序都必须有个main 包，同时该包里需要有一个main函数作为入口 如若需要引入其他包中的函数，可以用关键字import来引入， 保留字123break case chan const continue default defer else fallthrough for func go goto if import interface map package range return select structswitch type var 变量12345678910111213141516#var 关键字用来定义变量var variableName type#define egg:var name stringvar first_name, last_name string#define and assignvar name string = "jack ma" ===&gt; var name = "jack ma"var first_name, last_name = "jack", "ma"# := 的使用first_name, last_name := "jack", "ma"# 特殊变量 __, las_name := "jack", "ma" 注意：Golang 对于已声明但未使用的变量就会在编译阶段报错，如下代码在编译时就会产生一个错误 12345678 package mainimport "fmt"func main() &#123; name := "jack ma" fmt.Println("vim-go")&#125; 编译报错 12 go build./variable.go:6: name declared and not used 常量程序在编译过程中就确定的值，在运行过程中无法改变其值。 12345678 //单个 const A = 123 //多个 const ( Address = "0.0.0.0" Port = 8365) 数值类型 整数类型有无符号和带符号两种。Go同时支持int和uint，这两种类型的长度相同，但具体长度取决于不同编译器的实现。Go里面也有直接定义好位数的类型：rune, int8, int16, int32, int64和byte, uint8, uint16, uint32,uint64。其中rune是int32的别称，byte是uint8的别称。 这些类型之间是不允许类型转化的。 浮点数的类型有float32和float64两种（没有float类型），默认是float64。 Boolean12var flag boolvar flag_a, flag_b = true, false 字符串12var name stringvar first_name = "jack" 字符串在声明之后是不可变的，这段代码则报错 12var s string = "hello"s[0] = 'c' 如果要改变字符串中某个字符，则需要进行类型转化在处理： 12345s := "hello"c := []byte(s) // 将字符串 s 转换为 []byte 类型c[0] = 'c's2 := string(c) // 再转换回 string 类型fmt.Printf("%s\n", s2) 简单的字符串处理函数 数组123456789101112var arr1 [10]stringvar arr2 [10] int#define &amp;&amp; assign// 声明了一个长度为3的int数组a := [3]int&#123;1, 2, 3&#125; // 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0b := [10]int&#123;1, 2, 3&#125; // 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度c := [...]int&#123;4, 5, 6&#125; 数组一经声明，就不能再改变长度，但在很多应用场景中，在初始定义数组时，我们并不知道需要多大的数组，因此我们就需要“动态数组”，在Golang里面这种数据结构称作切片，即slice slice并不是真正意义上的动态数组，而是一个引用类型。slice总是指向一个底层array，slice的声明也可以像array一样，只是不需要长度。 12345678910111213141516var slice1 []intslice := []byte &#123;'a', 'b', 'c', 'd'&#125;// 声明一个含有10个元素元素类型为byte的数组var ar = [10]byte &#123;'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'&#125;// 声明两个含有byte的slicevar a, b []byte// a指向数组的第3个元素开始，并到第五个元素结束，a = ar[2:5]//现在a含有的元素: ar[2]、ar[3]和ar[4]// b是数组ar的另一个sliceb = ar[3:5]// b的元素是：ar[3]和ar[4] slice的默认开始位置是0，ar[:n]等价于ar[0:n]slice的第二个序列默认是数组的长度，ar[n:]等价于ar[n:len(ar)]如果从一个数组里面直接获取slice，可以这样ar[:]，因为默认第一个序列是0，第二个是数组的长度，即等价于ar[0:len(ar)] 对于slice有几个有用的内置函数： len 获取slice的长度cap 获取slice的最大容量append 向slice里面追加一个或者多个元素，然后返回一个和slice一样类型的slice 字典123456789101112var map [int]stringvar map1 [string]string// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化var numbers map[string]int// 另一种map的声明方式numbers := make(map[string]int)numbers["one"] = 1numbers["ten"] = 10numbers["three"] = 3fmt.Println("第三个数字是: ", numbers["three"]) // 读取数据 使用map过程中需要注意的几点： map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取 map的长度是不固定的，也就是和slice一样，也是一种引用类型内置的len函数同样适用于map，返回map拥有的key的数量map的值可以很方便的修改，通过numbers[&quot;one&quot;]=11可以很容易的把key为one的字典值改为11map和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制 流程控制条件判断、循环控制、无条件跳转 if 12345if x &gt; 10 &#123; fmt.Println("x is greater than 10")&#125; else &#123; fmt.Println("x is less than 10")&#125; Golang支持在if 在条件语句里面声明变量，但该变量的作用域只是在改条件逻辑块里。 123456789// 计算获取值x,然后根据x返回的大小，判断是否大于10。if x := computedValue(); x &gt; 10 &#123; fmt.Println("x is greater than 10")&#125; else &#123; fmt.Println("x is less than 10")&#125;//这个地方如果这样调用就编译出错了，因为x是条件里面的变量fmt.Println(x) goto 12345678910func mygoto() &#123; i := 1Here: println(i) i++ if i &gt; 10 &#123; return &#125; goto Here&#125; goto 跳转到本函数内的标签，同时对标签大小写敏感 for 1234567func testFor() &#123; sum := 0 for index := 0; index &lt; 10; index++ &#123; sum += index &#125; fmt.Println("sum is equal to ", sum)&#125; 简写 1234sum := 1for sum &lt; 1000 &#123; sum += sum&#125; for 与 range 的使用（类似PHP foreach） 12345678numbers := make(map[string]int)numbers["test1"] = 1numbers["test2"] = 2for k,v:=range map &#123; fmt.Println("map's key:",k) fmt.Println("map's val:",v)&#125; structGo语言中，也和C或者其他语言一样，我们可以声明新的类型，作为其它类型的属性或字段的容器。例如，我们可以创建一个自定义类型person代表一个人的实体。这个实体拥有属性：姓名和年龄。这样的类型我们称之struct。如下代码所示: 1234type person struct &#123; name string age int&#125; 使用 1234567891011121314151617package mainimport "fmt"type Person struct &#123; name string age int&#125;func main() &#123; var person Person person.name = "Golang" person.age = 5 fmt.Println(person) fmt.Printf("The person's name is %s", P.name) &#125; 另外几种声明方法 12345p := Person&#123;"Golang", 5&#125;p := Person&#123;name:"Golang",age:5&#125;p := new (Person) egg: 12345678910111213/S-&gt;C 任务命令分发type Data struct &#123; Type string `json:"type"` Data json.RawMessage `json:"data"` Time string `json:"time"`&#125;//C-&gt;S 任务命令应答type Response struct &#123; Code int `json:"code"` Msg string `json:"msg"` Data json.RawMessage `json:"data"`&#125; 函数函数是Go里面的核心设计，它通过关键字func来声明，它的格式如下： 12345func funcName(input1 type1, input2 type2) (output1 type1, output2 type2) &#123; //这里是处理逻辑代码 //返回多个值 return value1, value2&#125; 上面的代码我们看出 关键字func用来声明一个函数funcName 函数可以有一个或者多个参数，每个参数后面带有类型，通过,分隔 函数可以返回多个值 上面返回值声明了两个变量output1和output2，如果你不想声明也可以，直接就两个类型 如果只有一个返回值且不声明返回值变量，那么你可以省略 包括返回值 的括号 如果没有返回值，那么就直接省略最后的返回信息 如果有返回值， 那么必须在函数的外层添加return语句 函数可以返回多个值，这个在其他语言中并不常见，看下面的例子 1234567891011121314151617package mainimport "fmt"//返回 A+B 和 A*Bfunc SumAndProduct(A, B int) (int, int) &#123; return A+B, A*B&#125;func main() &#123; x := 3 y := 4 xPLUSy, xTIMESy := SumAndProduct(x, y) fmt.Printf("%d + %d = %d\n", x, y, xPLUSy) fmt.Printf("%d * %d = %d\n", x, y, xTIMESy)&#125; Golang 函数支持变参，函数定义如下： 123func myfunc(arg ...int) &#123;&#125;func myfunc(arg ...interface) &#123;&#125; egg，构造数据库多条件查询 1234567891011121314151617181920212223242526272829func ProjectGetList(page int, pageSize int, filters ...interface&#123;&#125;) ([]*Project, int64) &#123; offset := (page - 1) * pageSize list := make([]*Project, 0) query := orm.NewOrm().QueryTable(TableName("project")) if len(filters) &gt; 1 &#123; l := len(filters) for k := 0; k &lt; l; k += 2 &#123; query = query.Filter(filters[k].(string), filters[k+1]) &#125; &#125; total, _ := query.Count() query.OrderBy("-id").Limit(pageSize, offset).All(&amp;list) return list, total&#125;//调用filters := make([]interface&#123;&#125;, 0)filters = append(filters, "status", 0)if !models.IsAdmin(this.userId) &#123; filters = append(filters, "user_id", this.userId)&#125;list, count := models.ProjectGetList(page, this.pageSize, filters...) defer（延迟）关键字在函数中使用defer，即延迟语句。可以在函数结束的时候执行 defer 后的逻辑，当我们在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前需要关闭相应的资源，不然很容易造成资源泄露等问题。 12345678910111213141516func ReadWrite() bool &#123; file.Open("file")// 做一些工作 if failureX &#123; file.Close() return false &#125; if failureY &#123; file.Close() return false &#125; file.Close() return true&#125; egg 12345listen, err := net.Listen("tcp4", Address+":"+strconv.Itoa(Port)) if err != nil &#123; return err &#125; defer listen.Close() 如果一个函数中使用了多个defer，函数结束时会按照“先进后出”的形式依次执行defer 逻辑块。]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
</search>
