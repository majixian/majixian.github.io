<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PHP 基础知识汇总(数组字符串篇)]]></title>
    <url>%2F2018%2F03%2F01%2FPHP_summary%2F</url>
    <content type="text"><![CDATA[PHP 基础知识汇总 开发过程中常见的一些操作用法，大多数是PHP自带方法，减少在代码编写中自己处理一些不必要的逻辑。 数组常用数组方法 判断是否是数组is_array() 函数用来判断一个变量是否是数组，用法如下： 12345678$arr = [ 'a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C', 'd' =&gt; 'D',];var_dump(is_array($arr)); 执行结果如下： 1bool(true) 获取数组值array_values() 方法用来获取一个数组的值，并给其建立数字索引，用法如下： 12345678$arr = [ 'a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C', 'd' =&gt; 'D',];print_r(array_values($arr)); 执行结果如下： 1234567Array( [0] =&gt; A [1] =&gt; B [2] =&gt; C [3] =&gt; D) 获取数组keyarray_keys() 方法用来获取一个数组的key，可指定返回某个元素的key，用法如下： 123456789$arr = [ 'a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C', 'd' =&gt; 'D',];print_r(array_keys($arr));print_r(array_keys($arr, 'B')); 执行结果如下： 1234567891011Array( [0] =&gt; a [1] =&gt; b [2] =&gt; c [3] =&gt; d)Array( [0] =&gt; b) 转化数组KV值array_flip() 函数用来交换数组的键值，如果某个值存在多次，则以最后一个键名作为它的值，用法如下： 12345678$arr = [ 'a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C', 'd' =&gt; 'D',];print_r(array_flip($arr)); 执行结果如下： 1234567Array( [A] =&gt; a [B] =&gt; b [C] =&gt; c [D] =&gt; d) 检查数组是否存在某个keyarray_key_exists() 函数用来判断数组中是否存在某个key，用法如下： 12345678$arr = [ 'a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C', 'd' =&gt; 'D',];var_dump(array_key_exists('a', $arr)); 执行结果如下： 1bool(true) 检查数组是否存在某个值in_array() 函数用来判断数组中是否存在某个元素，用法如下： 12345678$arr = [ 'a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C', 'd' =&gt; 'D',];var_dump(in_array('B', $arr)); 执行结果如下： 1bool(true) 给数组追加元素array_push() 函数用来给数组追加一个元素，传引用，返回处理之后的元素数组的个数，用法如下： 123456789$arr = [ 'a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C', 'd' =&gt; 'D',];var_dump(array_push($arr, 'E'));print_r($arr); 执行结果如下： 123456789int(5)Array( [a] =&gt; A [b] =&gt; B [c] =&gt; C [d] =&gt; D [0] =&gt; E) 弹出数组的最后一个元素array_pop() 函数用来弹出数组最后一个元素（出栈），传引用，返回数组的最后一个元素，用法如下： 123456789$arr = [ 'a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C', 'd' =&gt; 'D',];var_dump(array_pop($arr));print_r($arr); 执行结果如下： 1234567string(1) "D"Array( [a] =&gt; A [b] =&gt; B [c] =&gt; C) 在数组开头插入元素array_unshift() 函数用来在数组开头插入一个或多个元素，传引用，返回处理后数组的元素个数，用法如下： 123456789$arr = [ 'a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C', 'd' =&gt; 'D',];var_dump(array_unshift($arr, 'E', 'F'));print_r($arr); 执行结果如下： 12345678910int(6)Array( [0] =&gt; E [1] =&gt; F [a] =&gt; A [b] =&gt; B [c] =&gt; C [d] =&gt; D) 移除数组开头的元素array_shift() 函数用来移除数组的第一个元素，传引用，返回数组第一个元素的值，用法如下： 123456789$arr = [ 'a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C', 'd' =&gt; 'D',];var_dump(array_shift($arr));print_r($arr); 执行结果如下： 1234567string(1) "A"Array( [b] =&gt; B [c] =&gt; C [d] =&gt; D) 获取数组随机元素array_rand() 函数用来获取数组的随机值，若只取一个则返回该元素的key，若取多个，则返回KV键值对，用法如下： 123456789$arr = [ 'a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C', 'd' =&gt; 'D',];var_dump(array_rand($arr, 1));print_r(array_rand($arr, 2)); 执行结果如下： 123456string(1) "a"Array( [0] =&gt; c [1] =&gt; d) 截取数组一段元素array_slice() 函数用来截取数组元素，返回数组，用法如下： 12345678$arr = [ 'a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C', 'd' =&gt; 'D',];print_r(array_slice($arr, 0, 2)); 执行结果如下： 12345Array( [a] =&gt; A [b] =&gt; B) 创建一个数组array_combine() 函数用来创建一个数组，用一个数组的值做键名，另一个数组的值作为值。用法如下： 12345$arr = ['a', 'b', 'c', 'd'];$arr1 = ['A', 'B', 'C', 'D'];print_r(array_combine($arr, $arr1)); 执行结果如下： 1234567Array( [a] =&gt; A [b] =&gt; B [c] =&gt; C [d] =&gt; D) 合并两个数组array_merge() 函数用来合并一个或多个数组的单元，数组的值附加在前一个数组后面，返回处理后的结果，如果输入的数组中有相同的字符串键名，则该键名后面的值将覆盖前一个值。然而，如果数组包含数字键名，后面的值将不会覆盖原来的值，而是附加到后面。如果只给了一个数组并且该数组是数字索引的，则键名会以连续方式重新索引。 用法如下： 12345678910111213$arr = [ 'a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C', 'd' =&gt; 'D',];$arr1 = [ 'e' =&gt; 'E', 'f' =&gt; 'F',];print_r(array_merge($arr, $arr1)); 执行结果如下： 123456789Array( [a] =&gt; A [b] =&gt; B [c] =&gt; C [d] =&gt; D [e] =&gt; E [f] =&gt; F) 合并两个数组，也可以用 + 操作符来做，它和array_merge()函数的区别是： array_merge() 后面的数组覆盖第一个, + 则保留相同key的第一个数组的值 保留第一个数组的键值 数组求交集array_intersect() 函数用来求两个个或多个数组的交集，返回数组保留第一个数组的键名，用法如下： 12345$arr = [a =&gt;'a', 'b', 'c', 'd'];$arr1 = ['a', 'b', 'C', 'D'];print_r(array_intersect($arr, $arr1)); 执行结果如下： 12345Array( [a] =&gt; a [0] =&gt; b) 数组求差集array_diff() 函数用来求两个或多个数组的差集，返回数组，键名保持不变，用法如下： 12345$arr = [a =&gt;'a', 'b', 'c', 'd'];$arr1 = ['a', 'b', 'C', 'D'];print_r(array_diff($arr, $arr1)); 执行结果如下： 12345Array( [1] =&gt; c [2] =&gt; d) 数组排序（正序）asort() 函数用来对数组进行排序并保持索引关系，传引用，返回TRUE/FALSE，排序之后数组索引保持不变，用法如下： 1234$arr = ['a' =&gt; 'y', 'b' =&gt; 'z', 'c' =&gt; 'x'];asort($arr);print_r(); 执行结果如下： 123456Array( [c] =&gt; x [a] =&gt; y [b] =&gt; z) 数组排序（逆序）arsort() 函数用来对数组进行排序并保持索引关系，传引用，返回TRUE/FALSE，排序之后数组索引保持不变，用法如下： 1234$arr = ['a' =&gt; 'y', 'b' =&gt; 'z', 'c' =&gt; 'x'];arsort($arr);print_r($arr); 执行结果如下： 12345( [b] =&gt; z [a] =&gt; y [c] =&gt; x) 获取数组的某一列array_column() 函数用来返回数组的某一列，用法如下： 12345678910111213141516171819202122232425262728$records = array( array( 'id' =&gt; 2135, 'first_name' =&gt; 'John', 'last_name' =&gt; 'Doe', ), array( 'id' =&gt; 3245, 'first_name' =&gt; 'Sally', 'last_name' =&gt; 'Smith', ), array( 'id' =&gt; 5342, 'first_name' =&gt; 'Jane', 'last_name' =&gt; 'Jones', ), array( 'id' =&gt; 5623, 'first_name' =&gt; 'Peter', 'last_name' =&gt; 'Doe', )); $first_names = array_column($records, 'first_name');//$first_names = array_column($records, 'first_name', 'id'); //用id做key//$first_names = array_column($records, null, 'id'); //用id做key返回所有列print_r($first_names); 执行结果如下： 1234567Array( [0] =&gt; John [1] =&gt; Sally [2] =&gt; Jane [3] =&gt; Peter) 字符串处理如下总结常用字符串处理函数. 求字符串长度strlen() 函数用来求字符串长度，用法如下: 12$str = 'abcdef';echo strlen($str); 执行结果如下： 16 字符串分割explode() 函数用来将一个字符串按指定分割符分割，用法如下: 12$str = 'a,b,c,d,e,f';print_r(explode(',', $str)); 执行结果如下： 123456789Array( [0] =&gt; a [1] =&gt; b [2] =&gt; c [3] =&gt; d [4] =&gt; e [5] =&gt; f) 一维数组变字符串implode() 函数用来将一个一维数组转化为字符串，用法如下： 12$arr = ['a','b','c','d','e','f'];echo implode(',', $arr); 执行结果如下： 1a,b,c,d,e,f 除去字符串首尾处空白trim() 函数用来除去字符串首尾处字符串空白字符，这些内容包括””,”\t”,”\n”,”\r”, “\0”, “\0xb”, 用法如下： 1234567891011121314$text = "\t\tThese are a few words :) ... ";$hello = "Hello World";var_dump($text, $binary, $hello);print "\n";$trimmed = trim($text);var_dump($trimmed);$trimmed = trim($text, " \t.");var_dump($trimmed);$trimmed = trim($hello, "Hdle");var_dump($trimmed); 执行结果如下： 12345678910111213/Users/majixian/a.php:4:string(32) " These are a few words :) ... "/Users/majixian/a.php:4:NULL/Users/majixian/a.php:4:string(11) "Hello World"/Users/majixian/a.php:9:string(28) "These are a few words :) ..."/Users/majixian/a.php:12:string(24) "These are a few words :)"/Users/majixian/a.php:15:string(5) "o Wor" 与trim() 函数类似，ltrim()函数和rtrim() 函数分别对字符串的左右两侧进行去空白。 替换str_replace() 函数用来替换字符串中的某些字符(串)，用法如下： 1234567891011121314151617181920// 赋值: &lt;body text='black'&gt;$bodytag = str_replace("%body%", "black", "&lt;body text='%body%'&gt;");echo $bodytag . "\n";// 赋值: Hll Wrld f PHP$vowels = array("a", "e", "i", "o", "u", "A", "E", "I", "O", "U");$onlyconsonants = str_replace($vowels, "", "Hello World of PHP");echo $onlyconsonants . "\n";// 赋值: You should eat pizza, beer, and ice cream every day$phrase = "You should eat fruits, vegetables, and fiber every day.";$healthy = array("fruits", "vegetables", "fiber");$yummy = array("pizza", "beer", "ice cream");$newphrase = str_replace($healthy, $yummy, $phrase);echo $newphrase . "\n";// 赋值: 2$str = str_replace("ll", "", "good golly miss molly!", $count);echo $count; 执行结果如下： 1234&lt;body text='black'&gt;Hll Wrld f PHPYou should eat pizza, beer, and ice cream every day.2 字符串重复str_repeat() 函数用来重复字符串，用法如下： 1echo str_repeat('test', 2); 执行结果如下： 1testtest 字符串切割转数组str_split() 函数用来将字符串转为数组，用法如下： 1234567$str = "Hello Friend";$arr1 = str_split($str);$arr2 = str_split($str, 3); //每个字符串的长度, 默认是1print_r($arr1);print_r($arr2); 执行结果如下： 12345678910111213141516171819202122Array( [0] =&gt; H [1] =&gt; e [2] =&gt; l [3] =&gt; l [4] =&gt; o [5] =&gt; [6] =&gt; F [7] =&gt; r [8] =&gt; i [9] =&gt; e [10] =&gt; n [11] =&gt; d)Array( [0] =&gt; Hel [1] =&gt; lo [2] =&gt; Fri [3] =&gt; end) 计算字符串中个字符信息12345$data = "Two Ts and one F.";foreach (count_chars($data, 1) as $i =&gt; $val) &#123; echo "There were $val instance(s) of \"" , chr($i) , "\" in the string.\n";&#125; 执行结果如下： 1234567891011There were 4 instance(s) of " " in the string.There were 1 instance(s) of "." in the string.There were 1 instance(s) of "F" in the string.There were 2 instance(s) of "T" in the string.There were 1 instance(s) of "a" in the string.There were 1 instance(s) of "d" in the string.There were 1 instance(s) of "e" in the string.There were 2 instance(s) of "n" in the string.There were 2 instance(s) of "o" in the string.There were 1 instance(s) of "s" in the string.There were 1 instance(s) of "w" in the string. 获取字符串中某个字串首次出现的位置strpos() 函数用来查找一个字符串中某个字符串首次出现的位置，需要注意的是，如果没找到，则返回false，如果找到并且在首部，则返回int（0）,用法如下： 12345$mystring = 'abc';$findme = 'a';$pos = strpos($mystring, $findme);var_dump($pos); 执行结果如下： 1int(0) 获取字符串的子串substr() 函数用来获取字符串的子串，用法如下： 12345678$rest = substr("abcdef", -1); // 返回 "f"$rest = substr("abcdef", -2); // 返回 "ef"$rest = substr("abcdef", -3, 1); // 返回 "d"$rest = substr("abcdef", 0, -1); // 返回 "abcde"$rest = substr("abcdef", 2, -1); // 返回 "cde"$rest = substr("abcdef", 4, -4); // 返回 ""$rest = substr("abcdef", -3, -1); // 返回 "de" 字符串转小写strtolower() 函数用来转化字符串为小写，用法如下： 123$str = "Mary Had A Little Lamb and She LOVED It So";$str = strtolower($str);echo $str; // 打印 mary had a little lamb and she loved it so 字符串转大写strtoupper() 函数用来转化字符串为大写，用法如下： 123$str = "Mary Had A Little Lamb and She LOVED It So";$str = strtoupper($str);echo $str; // 打印 MARY HAD A LITTLE LAMB AND SHE LOVED IT SO 特殊字符转html实体htmlspecialchars() 函数用来将特殊字符转为html实体，该函数对于防止web网站XSS攻击有很大作用，用法如下： 12$new = htmlspecialchars("&lt;a href='test'&gt;Test&lt;/a&gt;", ENT_QUOTES);echo $new; // &amp;lt;a href=&amp;#039;test&amp;#039;&amp;gt;Test&amp;lt;/a&amp;gt; 字符串转义addslashes() 函数用反斜线来引用字符串，在数据库信息入库等使用，防止sql注入，用法如下： 1234$str = "Is your name O'reilly?";// 输出： Is your name O\'reilly?echo addslashes($str);]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP卷学习笔记之概述篇]]></title>
    <url>%2F2018%2F01%2F01%2FTcp_ip_first%2F</url>
    <content type="text"><![CDATA[概述网络协议通常分不同层次开发，每一层负责不同的通信功能。TCP/IP其实是一个四层协议族，由上到下可分为应用层（Telent，FTP，e-mail）；运输层（TCP，UDP）；网络层（IP，ICMP，IGMP）；链路层（设备驱动卡程序及接口卡）。 数据链路层：操作程序中的设备驱动卡程序和计算机中对应的网络接口卡，包括ARP（地址解析协议）和RARP（逆地址解析协议），用来转化IP层和网络接口层的使用的地址。网络层：处理分组在网络中的活动，如分组的选路。包括IP（网际协议，网络层主要协议，被TCP和UDP使用，TCP和UDP的每组数据数据都通过端系统和每个中间路由器的IP层在互联网中进行传输）、ICMP（Internet互联网控制报文协议，IP协议的附属协议，IP层用它来和其他主机或路由器交换错误信息和其他重要信息）、IGMP（Internet互联网组管理协议，用来把一个UDP数据报广播到多个主机）。运输层：为两台主机上的应用程序提供端到端的通信。TCP（传输控制协议，提供高可靠新的数据通信），UDP（用户数据报协议，只是把称作数据报的分组从一台主机发送到另一台主机，不保证数据能到达另一端，一个数据报是指从发送发传输到接收方的一个信息单元）。应用层：FTP，Telnet等。 在TCP/IP协议族中，网络层IP提供了一种不可靠的服务，它是尽可能快的把分组从源节点发送到目的节点，TCP在不可靠的IP层提供了一个可靠地传输层（超时重发、接收端到端的确认和分组机制）。 互联网的地址：互联网上的每个接口必须有一个唯一的Internet地址（也称作IP地址），长32bit，IP地址具有一定的结构，五类不同地址格式如下： A类： 0.0.0.0 到 127.255.255.255B类： 128.0.0.0 到 191.255.255.255C类： 192.0.0.0 到 223.255.255.255D类 224.0.0.0 到 247.255.255.255 这些32位的地址通常写成四个十进制数，每个整数对应一个字节，我们称其为点分十进制表示法。 有三类IP地址，单播地址（目的为单个主机）、广播地址（目的端为给定网络上的所有主机）、多播地址（目的端位同一组内所有主机） //待续域名系统：]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[年终总结]]></title>
    <url>%2F2017%2F12%2F31%2FEndOf2017%2F</url>
    <content type="text"><![CDATA[时间好快，2107年都最后一天了，回头看看这一年，工作和生活上也算都有进步。 工作自去年参加工作以来，也算是兢兢业业。回顾这一年，有一段时间连续加班加点的奋斗，也有无心工作的惶惶恐恐。无心工作的惶恐大概是因为接手的需求都是简简单单代码的堆砌，让我感到技术成长举步不前。正是因为有这样的想法，所以自己也会从工作中跳出来，从另一个角度来促使技术成长，但也没有坚持多久。 Webcron 定时任务管理器 Webcron 是一个二次开发过的定时任务管理系统（源系统 https://github.com/lisijie/webcron）。二次开发过的系统由一个Master 和多个Agent 构成。由Master 向Agent 发送任务命令，定时任务调度由Agent 自己实现。系统由我和涛哥以及另外一个离职的同事一起开发，后期由于组织架构调整，再加上系统稳定运行（一年多未发生故障），后期没有维护。涛哥也忙其他一个项目，我来到了C 端。种种原因，项目没有再推广，后期UC 那边添加权限校验，我就再进行了优化升级。由于之前的版本一键部署功能再OP 这边无法通过，后来决定对其再优化升级，就有了当前上线的这一版，新版本优化了日志和权限系统，裁剪了一键部署的功能。 新版本系统上线以来，给同事们带来极大的便利，也得到了一致好评。以前定时任务的新增启动暂停都是委托OP来处理的，现在RD 可直接在系统上操作，对于那种一次性脚本来说真是太方便了，结合脚本执行超时或者错误的邮件短信报警，真是一个极好的产品。这个系统是PHP 转Golang 的一个尝试，虽然只是对线上业务的一个辅助工具，但我已经很满意了。这个系统后期申请了两天自运维的机器，由我来部署和更新，这样我可以大胆的尝试，有了新的进步。 掌链APP 掌链APP 一直是我去年切换到C 端之后负责的主要项目，从APP14 一直到现在到APP27，从刚开始的不熟悉到后来的游刃有余，期间经历了很多，大飞哥给予了很大的支持和帮助。掌链在经历过20+ 期的紧张迭代之后，不管是前端还是后端，页面展示数据和逻辑有很大的冗余，接口基本没有分版本，所以越往后接口越重，后期急需改版。详情页最为重要，我负责的详情页改版取得了不错的效果，简单来说，就是按照页面数据分模块拆接口，重要的数据请求直接展示，以前详情页的平均接口耗时在600+ms，改版之后给用户展示的效果是100ms就可以看到数据，大大提高了用户操作体验，同时，推动客户端继续优化，对详情页的头图获取方式再次优化，这样，用户在看到数据的同时，也能看到图片（以前是先获取数据，等好久才展示头图，体验很差）。 其他都是功能的迭代，没什么可圈可点的。不过组织调整，APP估计会在半年左右的时间推出历史舞台。接下来的这段时间希望能在APP开发中总结和学习，学习APP 开发流程以及后端架构设计和数据流转过程，也对这一年多的工作有一个新的交代。 生活生活上还是那么不温不火，但又觉得美滋滋。本命年有几件事还是挺重要的。 女友这一年很明朗，确定了这辈子要一起走的人。年初一起见了父母，双方都满意，我父母真是特别喜欢，以前上学（大学也是）的时候谈恋爱基本在我父母面前大家都是避而远之，后来毕业之后，就开始问的比较紧，直到前几天，我父母连着两天都说我结婚的事，我父亲说如果我没钱结婚的话他帮我出，赶紧结了，我真是有点诧异。 我本人生活懒散，不太会收拾，也不太会生活（双十一根本不知道买啥，平时去超市也不知道买啥，有时就买牙刷）。多亏了她，生活上给了很大的帮助，带着我买衣服，带着我吃东西。我们从高中认识，她比较内向，不怎么喜欢说话，而我恰恰相反。她早上去学校特别早，但是学习好像不怎么好，看着挺认真的。上了大学之后，才开始慢慢的交流，我在北京，她在平顶山，往返两地三五次。等她实习，选了北京的医院，开始打包大大小小的东西，送到我学校，后来我俩一起带到实习的地方，就像打工族一样，她们实习没有工资，同学四人蜗居在小房子里，挺艰难的。我每次去看她，都会买一包十块钱的小橘子，从学校提溜到她那，她笑的挺甜的（后来说起这个，她老是笑我每次都买橘子）。后来实习结束，陪她一起找工作，正式工作，等我毕业之后，大家收入也稍微好点，才慢慢生活的有个样子。 生活应该会越来越好吧。 家人以前上学的时候不知父母的艰难，等自己毕业工作了，才慢慢体会生活艰辛。内心深处和父母的感情也慢慢变得更加深沉，在他们眼里，我们可能永远都长不大。我们全家都不怎么善于表达，我母亲会借我父亲来教育和称赞我们。但是，越长大越爱他们。 今年最高兴的一件事就是带我母亲，姥姥姥爷，我舅和三个孩子在北京玩了一周。安排住宿，饮食，主要是女友在家人面前表现的淋漓尽致，得到一直好评，感谢。带他们游玩了北京的几个景点，姥爷七十多了，爬长城的时候特别兴奋。老人家闲谈，会说谁谁谁也没来过北京，作为晚辈，听了很高兴同时也有些伤感，12年上学的时候，父亲送我来学校，就在天安门前转了下，也没进去故宫，有点遗憾,剩下的日子希望能多带他们出来看看。 还有一件事就是我妹终于在艰难的补习复读之后考上了学校，也算是对自己高中有了交待。她十个很有想法的姑娘，但是好多事经历了才懂其中的道理，希望她的大学大放光彩，能够给她的人生有个转折的影响。 生活应该会越来越好吧。 朋友朋友其实不太多，大学的几个狗子厮混在一起。平常也会喝酒吃饭，在北京大家也算是相互有个照应。还有就是高中的几个好同伴，隔三差五大家也联系，日子过得也艰难，大家都不再是当年的高中生了，有自己的事业，生活。但我常常想起那几年的时光，无比的怀念，希望大家都有美好的生活和高尚的追求。 生活应该会越好越好吧 辞旧迎新16年也没列下什么计划，去了两地。 四月份去了上海，去迪士尼玩的很开心，也见了老朋友。 八月份去了北戴河，第一次去还是上学的时候去的。 新的一年，有很多的事需要去做 希望解决结婚买房大事。希望再去三个城市。希望读20本书。 2018，25岁过去，希望给自己有个完美的交代。希望每个人都有没好的未来。 【好久没写了，文笔生疏了】]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Supervisor 进程管理]]></title>
    <url>%2F2017%2F12%2F17%2FSupversior%2F</url>
    <content type="text"><![CDATA[系统运行过程中难免会有一些常驻进程帮助我们处理一些业务逻辑，类似消费者进程或者服务程序。我们通常通过nohup 的方式来启动并在后台运行这个进程，如需更好的管理和监测这类进程，需要用到Supervisor 来对这种常驻进程进行监测管理。 简介supervisor 是用Python开发的一套通用的进程管理程序，可以将一个进程变为后台daemon，并监控进程状态，如果进程出现异常，可自动重启。 安装1yum -y install supervisor 注：Centos下安装 配置配置全局信息安装完成后，可在 /etc 下看到 supervisor.conf 这个文件，如下是该文件部分内容（需要简单配置的） 123456789101112131415161718192021222324252627282930313233[unix_http_server]file=/tmp/supervisor.sock ; UNIX socket 文件，supervisorctl 会使用;chmod=0700 ; socket 文件的 mode，默认是 0700;chown=nobody:nogroup ; socket 文件的 owner，格式： uid:gid ;[inet_http_server] ; HTTP 服务器，提供 web 管理界面;port=127.0.0.1:9001 ; Web 管理后台运行的 IP 和端口，如果开放到公网，需要注意安全性;username=user ; 登录管理后台的用户名;password=123 ; 登录管理后台的密码 [supervisord]logfile=/tmp/supervisord.log ; 日志文件，默认是 $CWD/supervisord.loglogfile_maxbytes=50MB ; 日志文件大小，超出会 rotate，默认 50MBlogfile_backups=10 ; 日志文件保留备份数量默认 10loglevel=info ; 日志级别，默认 info，其它: debug,warn,tracepidfile=/tmp/supervisord.pid ; pid 文件nodaemon=false ; 是否在前台启动，默认是 false，即以 daemon 的方式启动minfds=1024 ; 可以打开的文件描述符的最小值，默认 1024minprocs=200 ; 可以打开的进程数的最小值，默认 200 ; the below section must remain in the config file for RPC; (supervisorctl/web interface) to work, additional interfaces may be; added by defining them in separate rpcinterface: sections[rpcinterface:supervisor]supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface [supervisorctl]serverurl=unix:///tmp/supervisor.sock ; 通过 UNIX socket 连接 supervisord，路径与 unix_http_server 部分的 file 一致;serverurl=http://127.0.0.1:9001 ; 通过 HTTP 的方式连接 supervisord ; 包含其他的配置文件[include]files = relative/directory/*.ini ; 可以是 *.conf 或 *.ini 配置不同的进程管理从上面的配置文件中我们看到有 12[include]files = relative/directory/*.ini ; 可以是 *.conf 或 *.ini 我们可以新建 /etc/supervisor.d 文件夹，将不同的项目启动配置放在里面。 新建a.conf，内容如下： 12345678910[program:monitor_cron_master]command=sh /xxx/xxx/xxx/xxx/supervisor_monitor.shautostart = true ; 在 supervisord 启动的时候也自动启动startsecs = 5 ; 启动 5 秒后没有异常退出，就当作已经正常启动了autorestart = true ; 程序异常退出后自动重启startretries = 3 ; 启动失败自动重试次数，默认是 3user = root ; 用哪个用户启动redirect_stderr = true ; 把 stderr 重定向到 stdout，默认 falsestdout_logfile = /xxx/xxx/xxx/monitor_cron_master.log 注意：我们可能在代码编写过程中没有注意到程序运行中的一些相对路径的依赖，这样command 配置有可能变成 1cd /xxx/xxx/xxx &amp;&amp; sh a.sh command 是不支持这种配置方式的，在这种情况下我们可把这个命令放到一个shell 文件中，用shell 来启动管理程序。 启动监控启动服务1service supervisord start 注：修改 /etc/supervisord.conf 之后需要重启服务才可生效 查看123supervisorctl statusmonitor_cron_master RUNNING pid 6766, uptime 5 days, 15:39:11 可以看到进程的状态时间等信息 重启暂停12supervisorctl restart monitor_cron_mastersupervisorctl stop monitor_cron_master 添加进程管理 在 /etc/supervisor.d 下配置文件之后 1supervisorctl reread 这个命令只影响新增的配置，不会影响之前运行中的状态，执行下面的操作即可查看 1supervisorctl update]]></content>
  </entry>
  <entry>
    <title><![CDATA[LT1求数组下标]]></title>
    <url>%2F2017%2F12%2F15%2FLeetcode_twoSum%2F</url>
    <content type="text"><![CDATA[我们开始练习第一道算法题。 题目Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 解法法一我们可以简单的用两层嵌套循环的方法找出来，当然这样是最差的一种解法，时间复杂度 O(n²)，如下 123456789101112131415func twoSum(nums []int, target int) []int &#123; k1 := 0 k2 := 0 for i := 0; i &lt; len(nums); i++ &#123; for j := i + 1; j &lt; len(nums); j++ &#123; if nums[i]+nums[j] == target &#123; k1 = i k2 = j break &#125; &#125; &#125; return []int&#123;k1, k2&#125;&#125; 法二我们可以借助简单的数据结构来实现更高效的解法。用Map，Map中查找一个数的时间复杂度为 O(1)，如下的解法时间复杂度可为 O(n) 12345678910111213141516171819202122func twoSum1(nums []int, target int) []int &#123; arr := make(map[int]int) var t, k1, k2 int for i := 0; i &lt; len(nums); i++ &#123; arr[nums[i]] = i &#125; for i := 0; i &lt; len(nums); i++ &#123; t = target - nums[i] v, ok := arr[t] if ok &amp;&amp; v != i &#123; k1 = i k2 = v break &#125; &#125; return []int&#123;k1, k2&#125;&#125;]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM 配置PHP错误检查]]></title>
    <url>%2F2017%2F12%2F13%2Fvimchecker_php%2F</url>
    <content type="text"><![CDATA[VIM，素有编辑器之神的美名，缘于其强大的功能和众多高效的插件。今天我们来看看如何进行简单的配置来提高PHP开发及调试的效率。 使用场景笔者在开发和测试过程当中，自己或者QA同学都会遇到因为遗漏某个括号，或者分号这种小的语法错误导致工作效率降低，特别是在测试或者是预上线环境，所以本文提供了一个在编辑退出时自动检查语法错误的工具，提高开发测试效率。 配置插件将下面这段代码添加至yourname.vim 文件中，并将该文件移至 ~/.vim/plugin 文件下即可 123456789101112autocmd BufWritePost *.php call PHPSyntaxCheck()if !exists('g:PHP_SYNTAX_CHECK_BIN') let g:PHP_SYNTAX_CHECK_BIN = 'php'endiffunction! PHPSyntaxCheck() let result = system(g:PHP_SYNTAX_CHECK_BIN.' -l -n '.expand('%')) if (stridx(result, 'No syntax errors detected') == -1) echohl WarningMsg | echo result | echohl None endifendfunction]]></content>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx配置文件初探]]></title>
    <url>%2F2017%2F12%2F11%2FNginxConfig%2F</url>
    <content type="text"><![CDATA[本文对nginx 配置进行简单的阐述与说明，官方配置文件参见 http://nginx.org/en/docs/example.html 配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#定义nginx运行的用户和用户组user www www;#nginx进程数，建议设置CPU总核心数worker_processes 2;#进程pid文件pid /var/run/nginx.pid;#[ debug | info | notice | warn | error | crit ] 全局错误日志定义类型error_log /var/log/nginx.error_log info;#指定进程可以打开的最大描述符：数目worker_rlimit_nofile 65535;events &#123; #单个进程最大连接数（最大连接数=连接数*进程数） worker_connections 2000; # use [ kqueue | epoll | /dev/poll | select | poll ]; 事件模型 use epoll;&#125;#设定http服务器，利用它的反向代理功能提供负载均衡支持http &#123; #文件扩展名与文件类型映射表 include conf/mime.types; #默认文件类型 default_type application/octet-stream; #日志格式设定 #$remote_addr记录客户端的ip地址； #$remote_user：用来记录客户端用户名称； #$time_local： 用来记录访问时间与时区； #$request： 用来记录请求的url与http协议； #$status： 用来记录请求状态；成功是200， #$body_bytes_sent ：记录发送给客户端文件主体内容大小； #$http_referer：用来记录从那个页面链接访问过来的； #$http_user_agent：记录客户浏览器的相关信息； log_format main '$remote_addr - $remote_user [$time_local] ' '"$request" $status $bytes_sent ' '"$http_referer" "$http_user_agent" ' '"$gzip_ratio"'; log_format download '$remote_addr - $remote_user [$time_local] ' '"$request" $status $bytes_sent ' '"$http_referer" "$http_user_agent" ' '"$http_range" "$sent_http_content_range"'; client_header_timeout 3m; client_body_timeout 3m; send_timeout 3m; #客户端请求缓冲区大小，该值必须设置为“系统分页大小”的整倍数 getconf PAGESIZE client_header_buffer_size 1k; large_client_header_buffers 4 4k; #开启gzip压缩输出 gzip on; #最小压缩文件大小 gzip_min_length 1100; #压缩缓冲区 gzip_buffers 4 8k; #压缩类型 gzip_types text/plain; output_buffers 1 32k; postpone_output 1460; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。 #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。 sendfile on; tcp_nopush on; tcp_nodelay on; send_lowat 12000; keepalive_timeout 75 20; #lingering_time 30; #lingering_timeout 10; #reset_timedout_connection on; server &#123; #监听端口号 listen 8800; server_name one.example.com www.one.example.com; #可多个 #日志文件地址 access_log /var/log/nginx.access_log main; error_log /var/log/nginx.error_log main; #对 "/" 启用反向代理 location / &#123; proxy_pass http://127.0.0.1/; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; #proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 可获取真是用户IP #允许客户端请求的最大单文件字节数 client_max_body_size 10m; #缓冲区代理缓冲用户端请求的最大字节数 client_body_buffer_size 128k; #client_body_temp_path设置记录文件的目录 可以设置最多3层目录 client_body_temp_path /var/nginx/client_body_temp; #nginx跟后端服务器连接超时时间(代理连接超时) proxy_connect_timeout 70; #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据 proxy_send_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) proxy_read_timeout 90; proxy_send_lowat 12000; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffer_size 4k; proxy_buffers 4 32k; #高负荷下缓冲大小（proxy_buffers*2） proxy_busy_buffers_size 64k; #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长 #设定缓存文件夹大小，大于这个值，将从upstream服务器传 proxy_temp_file_write_size 64k; proxy_temp_path /var/nginx/proxy_temp; #编码 charset koi8-r; &#125; error_page 404 /404.html; location /404.html &#123; root /spool/www; &#125; location /old_stuff/ &#123; rewrite ^/old_stuff/(.*)$ /new_stuff/$1 permanent; &#125; location /download/ &#123; valid_referers none blocked server_names *.example.com; if ($invalid_referer) &#123; #rewrite ^/ http://www.example.com/; return 403; &#125; #rewrite_log on; # rewrite /download/*/mp3/*.any_ext to /download/*/mp3/*.mp3 rewrite ^/(download/.*)/mp3/(.*)\..*$ /$1/mp3/$2.mp3 break; root /spool/www; #autoindex on; access_log /var/log/nginx-download.access_log download; &#125; #图片缓存时间设置 location ~* \.(jpg|jpeg|gif)$ &#123; root /spool/www; access_log off; expires 30d; &#125; &#125;&#125; 日志格式解析1234567891011http_x_real_ip：用户请求真实IPhttp_host：域名time_local：访问时间request：请求协议与urlrequest_length:请求长度status：请求状态body_bytes_sent：发送客户端主力内容大小request_time：请求耗时http_referer：从哪个链接进来http_user_agent：客户端浏览器信息remote_addr：反向代理IP 虚拟主机配置1234567891011121314151617181920212223242526server &#123; listen 80; server_name newhouseapi.fang.lianjia.com; root /data0/www/htdocs/newhouseapi.fang.lianjia.com/public; access_log /data0/www/logs/newhouseapi.fang.lianjia.com-access_log main; error_log /data0/www/logs/newhouseapi.fang.lianjia.com-error_log; location / &#123; root /data0/www/htdocs/newhouseapi.fang.lianjia.com/public; index index.php; if (!-e $request_filename)&#123; rewrite ^/(.*) /index.php?_url=/$1 last; &#125; &#125; location ~ \.php$ &#123; set $real_script_name $fastcgi_script_name; if ($fastcgi_script_name ~ /lianjia(/.*)$ ) &#123; set $real_script_name $1; &#125; fastcgi_pass 127.0.0.1:9096; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$real_script_name; include tengine.fastcgi_params; &#125;&#125; 示例请求转发我们先来看看最简单的转发配置， 12345678server &#123; listen 8801; server_name 127.0.0.1; location / &#123; proxy_pass http://127.0.0.1:8800/; &#125;&#125; 通过以上简单的配置，可将请求 转发至 在来看看另外一种用 upstream 进行转发的配置 1234567891011121314upstream my_server &#123; server 10.33.106.60:8122; keepalive 2000;&#125;server &#123; listen 8801; #server_name proxy.lianjia.com; location /newhouse/ &#123; proxy_pass http://my_server; proxy_set_header Host $host:$server_port; &#125;&#125; 需要注意的是，proxy_pass如果配置如下， 1proxy_pass http://my_server/; 则请求 会被转发至 ，这是因为proxy_pass参数中如果不包含url的路径，则会将location的pattern识别的路径作为绝对路径。 负载均衡nginx作为一个轻量级，高性能的WebServer，可作为http服务器，也可作反向代理器实现负载均衡。反向代理：以代理服务器来接收请求，然后将请求转发到内部网络上的服务器，获取结果，返回给客户端。来看看配置 1234567891011121314upstream myServer &#123; server 10.33.106.60:8122; server 10.33.107.19:8092;&#125;server &#123; listen 8802; #server_name proxy.lianjia.com; location / &#123; proxy_pass http://myServer; proxy_set_header Host $host:$server_port; &#125;&#125; 如上只是简单的进行了负载均衡的配置，nginx会按照轮询的方式将请求转发到不同的server，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 接着我们来看看upstream的分配策略 权重权重可指定轮询几率，weight和访问比例成正比，如下配置，19的访问比例比60高一倍 1234upstream myServer &#123; server 10.33.106.60:8122 weight=10; server 10.33.107.19:8092 weight=20;&#125; 访问IP每个请求按照IP的hash结果分配转发，每个访客都固定访问一个server 12345upstream myServer &#123; ip_hash server 10.33.106.60:8122; #不可加权重 server 10.33.107.19:8092;&#125; 后端响应时间按照后端服务器响应的时间来分配请求，响应时间段的优先分配 12345upstream myServer &#123; server 10.33.106.60:8122; server 10.33.107.19:8092; fair;&#125; 请求接口按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器 12345upstream myServer &#123; server 10.33.106.60:8122; #不可加权重 server 10.33.107.19:8092; hash $request_uri; &#125; 错误页面重写12345678910111213141516171819202122232425server &#123; listen 8805; #server_name proxy.lianjia.com; root /data0/www/htdocs/lnmp; location / &#123; fastcgi_intercept_errors on; root /data0/www/htdocs/lnmp; index index.php; error_page 404 /404.html; &#125; location ~ \.php$ &#123; set $real_script_name $fastcgi_script_name; if ($fastcgi_script_name ~ /lianjia(/.*)$ ) &#123; set $real_script_name $1; &#125; fastcgi_pass 127.0.0.1:9900; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$real_script_name; include fastcgi_params; &#125;&#125; 需要设置如下再配置404页面 1fastcgi_intercept_errors on; 资源http://tengine.taobao.org/book/chapter_02.html#id13]]></content>
      <tags>
        <tag>Lnmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang 基础知识]]></title>
    <url>%2F2017%2F12%2F10%2FGolang_first%2F</url>
    <content type="text"><![CDATA[Go 是一种新的语言，一种并发的、带垃圾回收的、快速编译的语言。 安装yum 安装1yum -y install goalng 源码安装移步Golang 官网 下载相应的源码包 1tar -xzf xxx.tar.gz -C /usr/local 环境配置查看当前环境12345678910111213141516 ~ go env GOARCH="amd64"GOBIN=""GOEXE=""GOHOSTARCH="amd64"GOHOSTOS="linux"GOOS="linux"GOPATH=""GORACE=""GOROOT="/usr/lib/golang"GOTOOLDIR="/usr/lib/golang/pkg/tool/linux_amd64"CC="gcc"GOGCCFLAGS="-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build643187888=/tmp/go-build"CXX="g++"CGO_ENABLED="1" 新建环境目录1234567vim .bash_profile//添加export GOPATH=/data0/www/htdocs/goexport PATH=$PATH:$GOPATH/bin//生效source .bash_profile 创建工作目录1234567mkdir /data0/www/htdocs/go//可执行文件mkdir /data0/www/htdocs/go/bin//源代码mkdir /data0/www/htdocs/go/src//依赖包mkdir /data0/www/htdocs/pkg 测试在 /data0/www/htdocs/go/src 下新建 main.go，添加如下代码 12345678910package mainimport ( "fmt")func main() &#123; fmt.Println("Welcome to Golang!")&#125; 运行 12[root@10 src]# go run main.goWelcome to Golang! 其他命令12345678910111213141516171819202122232425~ goGo is a tool for managing Go source code.Usage: go command [arguments]The commands are: build compile packages and dependencies clean remove object files doc show documentation for package or symbol env print Go environment information fix run go tool fix on packages fmt run gofmt on package sources generate generate Go files by processing source get download and install packages and dependencies install compile and install packages and dependencies list list packages run compile and run Go program test test packages tool run specified go tool version print Go version vet run go tool vet on packages 基础知识梳理Exercise at https://tour.golang.org/welcome/1 通过上述简单的测试程序，我们简单做一个阐述： Golang是通过包（package）来组织代码 每一个可独立运行的程序都必须有个main 包，同时该包里需要有一个main函数作为入口 如若需要引入其他包中的函数，可以用关键字import来引入， 保留字123break case chan const continue default defer else fallthrough for func go goto if import interface map package range return select structswitch type var 变量12345678910111213141516#var 关键字用来定义变量var variableName type#define egg:var name stringvar first_name, last_name string#define and assignvar name string = "jack ma" ===&gt; var name = "jack ma"var first_name, last_name = "jack", "ma"# := 的使用first_name, last_name := "jack", "ma"# 特殊变量 __, las_name := "jack", "ma" 注意：Golang 对于已声明但未使用的变量就会在编译阶段报错，如下代码在编译时就会产生一个错误 12345678 package mainimport "fmt"func main() &#123; name := "jack ma" fmt.Println("vim-go")&#125; 编译报错 12 go build./variable.go:6: name declared and not used 常量程序在编译过程中就确定的值，在运行过程中无法改变其值。 12345678 //单个 const A = 123 //多个 const ( Address = "0.0.0.0" Port = 8365) 数值类型 整数类型有无符号和带符号两种。Go同时支持int和uint，这两种类型的长度相同，但具体长度取决于不同编译器的实现。Go里面也有直接定义好位数的类型：rune, int8, int16, int32, int64和byte, uint8, uint16, uint32,uint64。其中rune是int32的别称，byte是uint8的别称。 这些类型之间是不允许类型转化的。 浮点数的类型有float32和float64两种（没有float类型），默认是float64。 Boolean12var flag boolvar flag_a, flag_b = true, false 字符串12var name stringvar first_name = "jack" 字符串在声明之后是不可变的，这段代码则报错 12var s string = "hello"s[0] = 'c' 如果要改变字符串中某个字符，则需要进行类型转化在处理： 12345s := "hello"c := []byte(s) // 将字符串 s 转换为 []byte 类型c[0] = 'c's2 := string(c) // 再转换回 string 类型fmt.Printf("%s\n", s2) 简单的字符串处理函数 数组123456789101112var arr1 [10]stringvar arr2 [10] int#define &amp;&amp; assign// 声明了一个长度为3的int数组a := [3]int&#123;1, 2, 3&#125; // 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0b := [10]int&#123;1, 2, 3&#125; // 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度c := [...]int&#123;4, 5, 6&#125; 数组一经声明，就不能再改变长度，但在很多应用场景中，在初始定义数组时，我们并不知道需要多大的数组，因此我们就需要“动态数组”，在Golang里面这种数据结构称作切片，即slice slice并不是真正意义上的动态数组，而是一个引用类型。slice总是指向一个底层array，slice的声明也可以像array一样，只是不需要长度。 12345678910111213141516var slice1 []intslice := []byte &#123;'a', 'b', 'c', 'd'&#125;// 声明一个含有10个元素元素类型为byte的数组var ar = [10]byte &#123;'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'&#125;// 声明两个含有byte的slicevar a, b []byte// a指向数组的第3个元素开始，并到第五个元素结束，a = ar[2:5]//现在a含有的元素: ar[2]、ar[3]和ar[4]// b是数组ar的另一个sliceb = ar[3:5]// b的元素是：ar[3]和ar[4] slice的默认开始位置是0，ar[:n]等价于ar[0:n]slice的第二个序列默认是数组的长度，ar[n:]等价于ar[n:len(ar)]如果从一个数组里面直接获取slice，可以这样ar[:]，因为默认第一个序列是0，第二个是数组的长度，即等价于ar[0:len(ar)] 对于slice有几个有用的内置函数： len 获取slice的长度cap 获取slice的最大容量append 向slice里面追加一个或者多个元素，然后返回一个和slice一样类型的slice 字典123456789101112var map [int]stringvar map1 [string]string// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化var numbers map[string]int// 另一种map的声明方式numbers := make(map[string]int)numbers["one"] = 1numbers["ten"] = 10numbers["three"] = 3fmt.Println("第三个数字是: ", numbers["three"]) // 读取数据 使用map过程中需要注意的几点： map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取 map的长度是不固定的，也就是和slice一样，也是一种引用类型内置的len函数同样适用于map，返回map拥有的key的数量map的值可以很方便的修改，通过numbers[&quot;one&quot;]=11可以很容易的把key为one的字典值改为11map和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制 流程控制条件判断、循环控制、无条件跳转 if 12345if x &gt; 10 &#123; fmt.Println("x is greater than 10")&#125; else &#123; fmt.Println("x is less than 10")&#125; Golang支持在if 在条件语句里面声明变量，但该变量的作用域只是在改条件逻辑块里。 123456789// 计算获取值x,然后根据x返回的大小，判断是否大于10。if x := computedValue(); x &gt; 10 &#123; fmt.Println("x is greater than 10")&#125; else &#123; fmt.Println("x is less than 10")&#125;//这个地方如果这样调用就编译出错了，因为x是条件里面的变量fmt.Println(x) goto 12345678910func mygoto() &#123; i := 1Here: println(i) i++ if i &gt; 10 &#123; return &#125; goto Here&#125; goto 跳转到本函数内的标签，同时对标签大小写敏感 for 1234567func testFor() &#123; sum := 0 for index := 0; index &lt; 10; index++ &#123; sum += index &#125; fmt.Println("sum is equal to ", sum)&#125; 简写 1234sum := 1for sum &lt; 1000 &#123; sum += sum&#125; for 与 range 的使用（类似PHP foreach） 12345678numbers := make(map[string]int)numbers["test1"] = 1numbers["test2"] = 2for k,v:=range map &#123; fmt.Println("map's key:",k) fmt.Println("map's val:",v)&#125; structGo语言中，也和C或者其他语言一样，我们可以声明新的类型，作为其它类型的属性或字段的容器。例如，我们可以创建一个自定义类型person代表一个人的实体。这个实体拥有属性：姓名和年龄。这样的类型我们称之struct。如下代码所示: 1234type person struct &#123; name string age int&#125; 使用 1234567891011121314151617package mainimport "fmt"type Person struct &#123; name string age int&#125;func main() &#123; var person Person person.name = "Golang" person.age = 5 fmt.Println(person) fmt.Printf("The person's name is %s", P.name) &#125; 另外几种声明方法 12345p := Person&#123;"Golang", 5&#125;p := Person&#123;name:"Golang",age:5&#125;p := new (Person) egg: 12345678910111213/S-&gt;C 任务命令分发type Data struct &#123; Type string `json:"type"` Data json.RawMessage `json:"data"` Time string `json:"time"`&#125;//C-&gt;S 任务命令应答type Response struct &#123; Code int `json:"code"` Msg string `json:"msg"` Data json.RawMessage `json:"data"`&#125; 函数函数是Go里面的核心设计，它通过关键字func来声明，它的格式如下： 12345func funcName(input1 type1, input2 type2) (output1 type1, output2 type2) &#123; //这里是处理逻辑代码 //返回多个值 return value1, value2&#125; 上面的代码我们看出 关键字func用来声明一个函数funcName 函数可以有一个或者多个参数，每个参数后面带有类型，通过,分隔 函数可以返回多个值 上面返回值声明了两个变量output1和output2，如果你不想声明也可以，直接就两个类型 如果只有一个返回值且不声明返回值变量，那么你可以省略 包括返回值 的括号 如果没有返回值，那么就直接省略最后的返回信息 如果有返回值， 那么必须在函数的外层添加return语句 函数可以返回多个值，这个在其他语言中并不常见，看下面的例子 1234567891011121314151617package mainimport "fmt"//返回 A+B 和 A*Bfunc SumAndProduct(A, B int) (int, int) &#123; return A+B, A*B&#125;func main() &#123; x := 3 y := 4 xPLUSy, xTIMESy := SumAndProduct(x, y) fmt.Printf("%d + %d = %d\n", x, y, xPLUSy) fmt.Printf("%d * %d = %d\n", x, y, xTIMESy)&#125; Golang 函数支持变参，函数定义如下： 123func myfunc(arg ...int) &#123;&#125;func myfunc(arg ...interface) &#123;&#125; egg，构造数据库多条件查询 1234567891011121314151617181920212223242526272829func ProjectGetList(page int, pageSize int, filters ...interface&#123;&#125;) ([]*Project, int64) &#123; offset := (page - 1) * pageSize list := make([]*Project, 0) query := orm.NewOrm().QueryTable(TableName("project")) if len(filters) &gt; 1 &#123; l := len(filters) for k := 0; k &lt; l; k += 2 &#123; query = query.Filter(filters[k].(string), filters[k+1]) &#125; &#125; total, _ := query.Count() query.OrderBy("-id").Limit(pageSize, offset).All(&amp;list) return list, total&#125;//调用filters := make([]interface&#123;&#125;, 0)filters = append(filters, "status", 0)if !models.IsAdmin(this.userId) &#123; filters = append(filters, "user_id", this.userId)&#125;list, count := models.ProjectGetList(page, this.pageSize, filters...) defer（延迟）关键字在函数中使用defer，即延迟语句。可以在函数结束的时候执行 defer 后的逻辑，当我们在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前需要关闭相应的资源，不然很容易造成资源泄露等问题。 12345678910111213141516func ReadWrite() bool &#123; file.Open("file")// 做一些工作 if failureX &#123; file.Close() return false &#125; if failureY &#123; file.Close() return false &#125; file.Close() return true&#125; egg 12345listen, err := net.Listen("tcp4", Address+":"+strconv.Itoa(Port)) if err != nil &#123; return err &#125; defer listen.Close() 如果一个函数中使用了多个defer，函数结束时会按照“先进后出”的形式依次执行defer 逻辑块。]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LNMP 环境搭建]]></title>
    <url>%2F2017%2F12%2F10%2FLNMP%2F</url>
    <content type="text"><![CDATA[首先介绍一下LNMP环境，LNMP即 Linux+Nginx+MySql+Php 组建的一套成熟完善的Web环境。本文总结了LNMP环境搭建的方法步骤以及过程当中可能遇到到问题。 目标安装环境如下：Linux &nbsp;&nbsp;CentOS 6.8Nginx &nbsp;&nbsp;1.10.2MySql &nbsp;&nbsp;5.6PHP &nbsp;&nbsp; &nbsp;&nbsp;5.5.38 成功安装LNMP环境到/usr/local/lnmp 准备工作本地目录创建12345mkdir /usr/local/lnmp mkdir /usr/local/lnmp/mysql5.6mkdir /usr/local/lnmp/nginx1.10.2mkdir /usr/local/lnmp/php5.5.38mkdir /usr/local/source #源码存放目录 源码准备1234cd /usr/local/sourcewget http://am1.php.net/get/php-5.5.38.tar.gz/from/this/mirror&amp;&amp; mv mirror php-5.5.38.tar.gz wget http://nginx.org/download/nginx-1.10.2.tar.gzwget https://github.com/mysql/mysql-server/archive/mysql-5.5.56.tar.gz PHP 安装解压安装包12cd /usr/local/sourcetar -zxvf php-5.5.38.tar.gz &amp;&amp; cd php-5.5.38 编译&amp;安装123456789101112131415161718192021#配置编译选项./configure \--prefix=/usr/local/lnmp/php5.5.38 \--enable-fpm \--with-zlib-dir=/usr/share/doc/zlib-1.2.11 \--enable-mbstring \--with-openssl-dir=/usr/share/doc/openssl-1.0.2d \ --with-mysql --with-mysqli \--with-mysql-sock \--with-jpeg-dir=/usr/lib \--enable-gd-native-ttf \--enable-pdo --with-pdo-mysql \--with-gettext --with-pdo-mysql \--with-curl=/usr/share/doc/curl-7.19.7 \--enable-sockets --enable-bcmath --enable-xml \--with-bz2 --enable-zip --enable-freetype#编译&amp;&amp;安装make &amp;&amp; make install#详细全部的安装命令参见 配置1234cd /usr/local/lnmp/php5.5.38/etccp php-fpm.conf.default php-fpm.conf若不存在php.ini文件，则拷贝一份源码文件中的出来cp /usr/local/source/php-5.5.38/php.ini-development /usr/local/lnmp/php5.5.38/etc 修改默认配置12//修改php-fpm.conf 默认端口号listen = 127.0.0.1:9900 启动1/usr/local/lnmp/php5.5.38/sbin/php-fpm 注意事项基础环境因个人机器而异，如若需要依赖，编译过程当中自会提示，总结需要安装的依赖大致如下，yum安装即可 123456789yum -y install \libcurl4-openssl-dev \pkg-config openssl \openssl-devel bzip2-devel libjpeg \libjpeg-devel png-devel libpng-devel \freetype-devel openldap-devel.i386 \openldap-devel libmcrypt-devel \sqlite3-devel sqlite-devel libtidy \libtidy-devel install libxslt-devel Nginx 安装解压安装包12cd /usr/local/sourcetar -zxvf nginx-1.10.2.tar.gz &amp;&amp; cd nginx-1.10.2 编译&amp;安装12345# 配置编译选项./configure --prefix=/usr/local/lnmp/nginx1.10.2# 编译&amp;&amp;安装make &amp;&amp; make install 检查及启动12/usr/local/lnmp/nginx.1.10.2/sbin/nginx -v #查看版本号/usr/local/lnmp/nginx.1.10.2/sbin/nginx 注意事项 举个栗子，安装过程中可能遇到下面这个错误， 1error：the HTTP rewrite module requires the PCRE library pcre是nginx在rewrite伪静态匹配规则用的正则库，我们用yum安装最新pcre如下，再次尝试无果，查阅相关资料，安装pcre-devel即可，关于pcre和pcre-devel区别， MySql 安装解压安装包12cd /usr/local/sourcetar -zxvf mysql-5.5.56.tar.gz &amp;&amp; cd mysql-server-mysql-5.5.56 编译&amp;安装1234567891011121314151617181920212223# mysql从5.5起，源码安装使用cmake，首先安装cmakeyum -y install cmake# 配置编译选项cmake \-DCMAKE_INSTALL_PREFIX=/usr/local/lnmp/mysql5.6 \-DMYSQL_DATADIR=/usr/local/lnmp/mysql5.6/data \-DSYSCONFDIR=/etc \-DWITH_MYISAM_STORAGE_ENGINE=1 \-DWITH_INNOBASE_STORAGE_ENGINE=1 \-DWITH_MEMORY_STORAGE_ENGINE=1 \-DWITH_READLINE=1 \-DMYSQL_UNIX_ADDR=/var/lib/mysql/mysql.sock \-DMYSQL_TCP_PORT=3306 \-DENABLED_LOCAL_INFILE=1 \-DWITH_PARTITION_STORAGE_ENGINE=1 \-DEXTRA_CHARSETS=all \-DDEFAULT_CHARSET=utf8 \-DDEFAULT_COLLATION=utf8_general_ci# 编译&amp;&amp;安装make &amp;&amp; make install编译参数可参见 http://dev.mysql.com/doc/refman/5.5/en/source-configuration-options.html 配置123456789101112131415161718192021cat /etc/passwd //查看⽤用户列列表cat /etc/group //查看⽤用户组列列表//若无mysql用户则创建groupadd mysqluseradd -g mysql mysql //修改/usr/local/lnmp/mysql5.6权限chown -R mysql:mysql /usr/local/lnmp/mysql5.6//初始化配置cd /usr/local/lnmp/mysql5.6 //如果未发现my.cnf，则拷贝一份 cp /usr/local/lnmp/mysql5.6/suport_files/my-default.cnf ../my.cnf//修改my.cnf默认配置datadir=/usr/local/lnmp/mysql5.6/data/mysqlport = 6000//初始化数据库/usr/local/lnmp/mysql5.6/scripts/mysql_install_db --user=mysql --basedir=/usr/local/lnmp/mysql5.6 启动1/usr/local/lnmp/mysql5.6/bin/mysqld_safe --defaults-file=/usr/local/lnmp/mysql5.6/my.cnf &amp; 注意事项 编译运行过程需要安装如下依赖（视不同机器情况而定） 1yum -y install ncurses-devel gcc gcc-c++ bison LNMP 运行配置查看php nginx mysql是否都已启动，若无启之 配置修改nginx配置如下 123456789101112131415161718192021server &#123; listen 8800; server_name testlnmp.lianjia.com; root /data0/www/htdocs/lnmp; location / &#123; root /data0/www/htdocs/lnmp; index index.php; if (!-e $request_filename)&#123; rewrite ^/(.*) /index.php last; &#125; &#125; location ~ \.php$ &#123; fastcgi_pass 127.0.0.1:9900; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$real_script_name; include fastcgi_params; &#125;&#125; 重启nginx1/usr/local/lnmp/nginx.1.10.2/sbin/nginx -s reload 测试 在/data0/www/htdocs/lnmp下新建index.php，输出‘hello word’ 访问 即可]]></content>
      <tags>
        <tag>Lnmp</tag>
      </tags>
  </entry>
</search>
